start Program

Program ::= [Module] "define(["/> requires:([Require] path:str)* @(.","/) </"]," /
                     "function(". requires:([Require] name:sym)* @(.",") .") {">/2
                     "var" name:sym ";"/
                     defs:Def* @/2 /2
                     name:sym "=" "{"/> defs:Export* /2 /<"};"/
                     "return" name:sym .";"/
                     <"})"/
Def     ::= Class | Mixin | [Binding]
Export ::= [Class] ExportName | [Mixin] ExportName | Binding
ExportName ::= name:sym .":" name:sym ."," /
Binding  ::= [Binding] name:sym .":" (value:Function | value:Expr) .","/2
  Function ::= FunHeader FunBody
  
// class N < N 
//   D* 
// end
// class 
// D ::= def N 

Class   ::= [Class] "var" name:sym "= MakeClass(">.
      (parent:Ref | "null") ."," Includes .","/ Meta .","/ Instance .<");"
Mixin   ::= [Mixin] "var" name:sym "= MakeMixin(". Includes ."," "function() {" Body "});"
Body    ::= /> defs:DefB* @/2 </
Includes ::= "[". includes:Ref* @(.",") ."]"

Instance ::= "function(super$) {" Body "}"
Meta    ::= "function() {"/> meta:DefB* @/2 </"}"
DefB     ::= Attribute | BindingM | BindingB
BindingM  ::= [Binding] "this.". MethodSym "=" Method .";"
BindingB  ::= [Binding] "this.$.". name:sym "=" value:Expr .";"
  MethodSym ::= {name=="[]"} "_get" | {name=="[]="} "_set" | name:sym
Method   ::= value:FunHeader value:FunBody
  FunHeader ::= [Fun] "function(". Params .") {" /> "var self = this; "/ args:Default* VarArg? Locals?
    VarArg ::= "var" rest:sym "= compute_rest_arguments(arguments," num_args:int ");" /
    Locals ::= "var" locals:Decl+ @(.",") .";" /
  Decl     ::= [Decl] name:sym ("=" default:Expr)?
  FunBody ::= [Fun] body:SeqBodyR </"}"
   
Attribute ::= [Attribute] ({ kind=="attr_reader" } Reader | { kind=="attr_accessor" } Reader / Writer)
Reader  ::= "this.". name:sym "=" "function()" "{" "return" "this"."."."$".".". name:sym "}" .";"
Writer  ::= "this.". "set_".name:sym "=" "function(val)" "{" "this"."."."$".".". name:sym " = val" "}" .";"

Seq     ::= "{"/> SeqBody </"}"
SeqBody     ::= [Seq] statements:Statement* @/ | Statement
SeqR     ::= "{"/> SeqBodyR </"}"
SeqBodyR     ::= [Seq] statements:StatementLR* @/ | StatementR

Statement ::= Basic | Expr .";"
StatementR ::= BasicR | "return" Expr .";"
StatementLR ::= {_last} StatementR | Statement
Basic   ::= If | While | TryCatch
If      ::= [If] "if" "(". cond:Expr .")" sthen:Seq ("else" (selse:If | selse:Seq))?
While   ::= [While] "while" "(". cond:Expr .")" body:Seq
TryCatch ::= [Rescue] "try" base:Seq rescues:Handler* ("finally" ensure:Seq)? 
Handler ::= [Handler] "catch" "(" (var:sym | "DUMMY") ")" body:Seq // TODO: deal with kind:str!!!

BasicR   ::= IfR | While | TryCatchR
IfR      ::= [If] "if" "(". cond:Expr .")" sthen:SeqR ("else" (selse:IfR | selse:SeqR))?
TryCatchR ::= [Rescue] "try" base:SeqR rescues:HandlerR* ("finally" ensure:Seq)? 
HandlerR ::= [Handler] "catch" "(" (var:sym | "DUMMY") ")" body:SeqR // TODO: deal with kind:str!!!

Expr ::= IndexAssign | CallAssign | Assign
IndexAssign ::= [Assign] to:([Index] base:Primary) ."._set(". to:([Index] index:Expr) ."," from:Assign .")"
CallAssign ::= [Assign] to:([Call] target:Primary) .".". to:([Call] method:sym) "=" from:Assign
 
Assign  ::= [Assign] to:Primary "=" from:Assign
        | EOr
EOr ::= [EBinOp] e1:EAnd op:"||" e2:EOr
       | EAnd
EAnd ::= [EBinOp] e1:EBinOp1 op:"&&" e2:EAnd
        | EBinOp1
EBinOp1 ::= [EBinOp] e1:EBinOp2 (op:"==" | op:"!=") e2:EBinOp1
         | EBinOp2
EBinOp2 ::= [EBinOp] e1:EBinOp3 (op:">" | op:"<" | op:">=" | op:"<=") e2:EBinOp2
         | EBinOp3
EBinOp3 ::= [EBinOp] e1:EBinOp3 (op:"<<" | op:">>" | op:"++") e2:EBinOp4
         | EBinOp4
EBinOp4 ::= [EBinOp] e1:EBinOp5 (op:"+" | op:"-") e2:EBinOp4
         | EBinOp5
EBinOp5 ::= [EBinOp] e1:EUnOp (op:"*" | op:"/" | op:"%") e2:EBinOp5
         | EUnOp
EUnOp ::= [EUnOp] (op:"!" | op:"-") e:EUnOp
        | EBinOp6
EBinOp6 ::= [EBinOp] e1:Primary op:"**" e2:EBinOp6
         | Primary


Primary ::= InstVar | ClassVar | Nil | Var | Ref | Super |  IfE | List | Index | Record | Fun | Call | Lit | "(". Expr .")" | 
             "((function(){" SeqR "})())"
InstVar ::= [Var] "self.$.". name:sym { kind=="@" }
ClassVar::= [Var] "self._class_.$.". name:sym { kind=="@@" }
Nil     ::= [Var] "null" { name == "nil" }
Var     ::= [Var] name:sym
Ref     ::= [Ref] (module:sym.".".)? name:sym
List    ::= [List] "[". items:Expr* @(.",") ."]"
Index   ::= [Index] base:Primary ."._get(". index:Expr .")"
Record  ::= [Record] "new" "EnsoHash" "(" "{" fields:Field* @(.",") "}" ")"
  Field   ::= [Binding] name:sym .":" value:Expr
Lit     ::= [Lit] value:atom
IfE      ::= [If] cond:Expr /> "?" sthen:Expr / ":" selse:Expr </     // TODO: Precedence!!

Call     ::= SuperCall | CallRest | CallNorm
CallRest  ::= [Call] Target .".apply(".target:Primary .", [". Args? ."].concat(" rest:Expr "))"
CallNorm  ::= [Call] Target ({method=="length"} | ."(". Args? .")")
  Target ::= {method=="call"} target:Primary | (target:Primary .".".)? method:sym
  Args    ::= (block:Primary .",")? args:Expr+ @(.",") 
            | block:Primary
SuperCall     ::= [Call] target:Super .".". method:sym (SuperRestArgs | SuperInvoke)
  SuperRestArgs ::= .".apply(self, [". Args? ."].concat(" rest:Expr "))"
  SuperInvoke ::= .".call(self" (."," Args)? .")"
  Super ::= [Super] "super$"
  
Fun     ::= [Fun] "function(". Params .")" "{"/> args:Default* VarArg? body:SeqBodyR </"}"
Params  ::=  (block:sym .",")? args:Param+ @(.",")
          | block:sym?
Param     ::= [Decl] name:sym
Default     ::= [Decl] ("if (". name:sym "=== undefined)" name:sym "=" default:Expr .";" /)?
  